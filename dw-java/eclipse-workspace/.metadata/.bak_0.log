!SESSION 2023-04-05 09:05:06.060 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\github\dw-java\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2023-04-05 10:29:42.079

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:42.080
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:42.080
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:43.152
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/오백원 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:29:43.156
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:29:43.158
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:47.856
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/오백원 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:29:47.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:29:47.859
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:50.096
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:50.097
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:50.098
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:50.159
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:29:50.160
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:29:50.161
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:51.638
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:29:51.641
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:29:51.642
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:53.106
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원  ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:53.107
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:53.107
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:54.128
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 < ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:54.130
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:54.132
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:54.894
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 < ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:29:54.898
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:29:54.900
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:58.162
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원  ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:58.164
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:58.165
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:29:59.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 > ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:29:59.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:29:59.692
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:01.705
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 > 0 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:01.707
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:01.708
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:02.429
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 > 0 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:02.430
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:02.432
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:03.926
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈/%오백원 > 0 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:03.928
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:03.929
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:17.239
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:17.241
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:17.241
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:18.254
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:18.255
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:18.255
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:24.254
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:24.255
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:24.256
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:25.374
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:25.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:25.376
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:27.374
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:27.377
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:27.378
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:36.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} if e
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:36.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:36.279
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:38.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:38.789
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:38.789
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:40.297
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if ()
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:40.298
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:40.298
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:41.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if ()
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:41.208
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:41.209
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:42.311
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if () {
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:42.313
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:42.314
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:43.835
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:43.838
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:43.839
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:45.677
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:45.680
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:45.681
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:48.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:48.461
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:48.461
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:50.358
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:50.361
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:50.363
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:56.378
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:30:56.381
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:30:56.383
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:30:57.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:30:57.333
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:30:57.334
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:00.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:00.413
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:00.415
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:02.434
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:02.435
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:02.436
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:07.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 500원 = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:07.462
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:07.463
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:08.190
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 500원 = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:08.192
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:08.193
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:09.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int 500원 = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:09.760
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:09.761
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:12.974
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int  = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:12.975
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:12.975
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:13.933
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int  = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:13.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:13.935
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:27.990
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:27.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:27.992
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:29.082
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:29.084
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:29.084
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:34.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-05 10:31:34.019
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-05 10:31:34.020
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:35.361
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:35.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:35.366
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:43.541
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:43.542
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:43.542
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:47.574
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:47.575
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:47.576
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:48.668
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:48.671
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:48.674
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:48.893
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:48.894
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:48.895
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:49.965
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:49.967
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:49.967
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:51.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:51.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:51.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-05 10:31:53.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package d_array;

import java.util.Arrays;
import java.util.Scanner;

import javax.swing.text.html.MinimalHTMLWriter;

public class Array {

	public static void main(String[] args) {
		
		//=======================================절취선=======================================

		/*
		 * << 배열 >>
		 * - 여러개의 값을 하나의 변수에 저장해서 사용하는 것이다.
		 * - 참조형 타입이다.
		 * - 인덱스로 값을 구분한다.
		 * - 길이를 변경할 수 없다.
		 */
		
//		int[] array; // 배열의 주소를 저장할 공간이 만들어진다.
//		array = new int[5]; //배열을 생성하고 그 주소가 저장된다.
		
//		int[] array2 = new int[5];
		
//		array = new int[] {1, 2, 3, 4, 5};
//		array = {1, 2, 3, 4, 5}; // 이 방법은 변수의 선언과 초기화를 동시에 해야한다.
//		int[] array2 = {1, 2, 3, 4, 5};
		
//		System.out.println(array2[0]);
//		System.out.println(array2[1]);
//		System.out.println(array2[2]);
//		System.out.println(array2[3]);
//		System.out.println(array2[4]);
		
//		int sum = 0;
//		for(int i = 0; i < array2.length; i++) {
//			sum += array2[i];
//		}
//		System.out.println("합계: " + sum);
		
//		int[] arrayx;
//		arrayx = new int[10];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			arrayx[i] = (int)(Math.random() * 100) + 1;
//		}
//		System.out.println(Arrays.toString(arrayx)); // 배열의 값들을 불러오는 방법이다.
//		
//		// 위에서 만든 임의의 숫자 10개 배열에서 최대값과 최소값을 구해주세요.
//		// max와 min을 선언하고 배열들과 비교하여 for문으로 반복한 arrayx[i] 중에서 가장 큰 값이 결국 마지막 max값이 되고, 가장 작은 값이 마지막 min값이 된다.
//
//		int max = arrayx[0];
//		int min = arrayx[0];
//		
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//				
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//				
//			}
//		}
//		System.out.println(max + "맥시멈 값");
//		System.out.println(min + "미니멈 값");
		
		//답안
//		int max = arrayx[0];
//		int min = arrayx[0];
//		for (int i = 0; i < arrayx.length; i++) {
//			if (arrayx[i] > max) {
//				max = arrayx[i];
//			} else if (arrayx[i] < min) {
//				min = arrayx[i];
//			}
//		}
//		System.out.println("최대값은 " + max + " 입니다.");
//		System.out.println("최소값은 " + min + " 입니다.");
		
		
		
		//=======================================절취선=======================================
		
		// 1 ~ 10 까지의 숫자를 배열 x에 랜덤하게 배치하세요.
//		int[] x = new int[10];
//		
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1); // x[i]의 랜덤한 값을 호출함
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) { // x[i]와 x[j]의 값이 같다면
//					i--; // i의 수를 감소시킨다.
//					// *중요 : 반복문에서 i는 현재 생성될 요소를 나타내고, j는 이전에 생성된 요소를 나타낸다.
//				}
//			}
//		}
//		System.out.println(Arrays.toString(x));
		
		// 답안
//		for (int i = 0; i < x.length; i++) {
//			x[i] = (int)(Math.random() * 10 + 1);
//			for (int j = 0; j < i; j++) {
//				if (x[i] == x[j]) {
//					i--;
//				}
//			}
//		}
//		System.out.print(Arrays.toString(x));
		
		//=======================================절취선=======================================

		// 0 ~ 9 사이의 랜덤값을 500번 생성하고, 각 숫자가 생성된 횟수를 배열에 담아 출력해주세요.

//		int[] array = new int[10]; // 배열을 생성한다.
//		for (int i = 0; i < 500; i++) { // 500번 반복하는 for 문을 만든다.
//			int randumNum = (int)(Math.random()*10); // randumNum으로 0~9까지 랜덤한 숫자를 선언한다.
//			array[randumNum] += 1; // array 배열의 [randumNum]번째인 위치에 +1을 시켜준다.
//		} // 즉 0 1 2 3 .. 9 이렇게 각 배열의 위치에 숫자가 호출될때마다 +1이 된다.
//		System.out.println(Arrays.toString(array));
		
		//답안
//		int[] ax = new int[10]; // {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
//		for (int i = 0; i < 500; i++) {
//			int a = (int)(Math.random() * ax.length);
//			ax[a] += 1;
//		}
//		System.out.println(Arrays.toString(ax)); // 1부터 10까지의 숫자가 각각 호출된 횟수들을 각 자리에 나열함
		
		//=======================================절취선=======================================
		
		// 위 문제의 최소값, 최대값, 반복횟수를 입력받아 각 숫자가 생성된 횟수를 출력해주세요.
		
//		//스캐너 생성
//		Scanner s = new Scanner(System.in);
//		//최소값
//		System.out.println("범위를 설정합니다.\n최소값을 입력해주세요.");
//		int inputMin = Integer.parseInt(s.nextLine());
//		//최대값
//		System.out.println("범위를 설정합니다.\n최대값을 입력해주세요.");
//		int inputMax = Integer.parseInt(s.nextLine());
//		//반복횟수
//		System.out.println("반복 횟수를 설정합니다.\n원하는 횟수를 입력해주세요.");
//		int inputRepeat = Integer.parseInt(s.nextLine());
//		//설정값
//		System.out.println("최소값은 " + inputMin + ", " +
//				"최대값은 " + inputMax + ", " +
//				"반복 횟수는 " + inputRepeat + " 입니다."
//				);
//		
//		//배열 등등 생성 및 선언
//		int array[] = new int[inputMax - inputMin + 1]; // 최대값 - 최소값으로 범위를 구한다
//		int min = array[0]; // 최소값
//		int max = array[0]; // 최대값
//		
//		for (int i = 1; i <= inputRepeat; i++) {
//			int randomNum = (int)(Math.random() * (inputMax - inputMin + 1) + inputMin); 
//			// ㄴ 최소값과 최대값의 범위를 구하고 마지막에 최소값을 더해줘야 0부터 시작이 아니다.
//			array[randomNum - inputMin] += 1;
//		}
//		System.out.println(Arrays.toString(array));
		
		//=======================================절취선=======================================

		/*
		 * 거스름돈에 동전의 단위마다 몇개의 동전이 필요한지 출력해주세요.
		 * 거스름돈 : 2860 -> random() 5000원 미만
		 * 500원 : 5개
		 * 100원 : 3개
		 * 50원 : 1개
		 * 10원 : 1
		 */
		
		//첫번째 방법
//		Scanner s = new Scanner(System.in);
//		for ( ; ; ) {
//			System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
//			int inputNum = Integer.parseInt(s.nextLine());
//			
//			int 거스름돈 = inputNum;
//			int 오백원 = 거스름돈 / 500;
//			int 백원 = (거스름돈 - 500*오백원) / 100;
//			int 오십원 = (거스름돈 - (500*오백원) - (100*백원)) / 50;
//			int 십원 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원)) / 10;
//			int 최종 = (거스름돈 - (500 * 오백원) - (100 * 백원) - (50 * 오십원) - (10 * 십원)) / 10;
//			
//			System.out.println(
//				"설정한 거스름돈은 " + 거스름돈 + " 입니다.\n" +
//				"500원 : " + 오백원 + "개, " +
//				"100원 : " + 백원 + "개, " +
//				"50원 : " + 오십원 + "개, " +
//				"10원 : " + 십원 + "개\n"
//			);
//		}
		
		//두번째 방법
		Scanner s = new Scanner(System.in);
		System.out.println("거스름돈을 설정해주세요. 필요한 갯수를 알려드립니다.");
		int inputNum = Integer.parseInt(s.nextLine());
		
		int 거스름돈 = inputNum;
		int 오백원 = 500;
		int 백원 = 100;
		int 오십원 = 50;
		int 십원 = 10;
//		int 최종 = 
		
		for ( ; ; ) {
			거스름돈 / 오백원 
		}
		
		if (거스름돈 > 0 ) {
			int = 거스름돈 / 오백원;
		} else if () {}
		
		
		
		
		
		
		
		
		
		
		
		//=======================================절취선=======================================

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-05 10:31:53.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-05 10:31:53.908
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:37:02.075
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:37:05.947
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:37:43.538
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:41:17.339
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:42:38.806
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:42:53.298
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:46:27.650
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:47:08.531
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:47:40.832
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 10:47:57.297
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:05:36.041
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:05:37.198
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:05:38.307
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:05:55.238
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:08:51.212
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:10:44.292
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:12:30.357
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:12.458
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:14.043
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:26.801
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:28.748
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:29.943
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:30.959
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:33.735
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:34.973
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:36.991
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:38.212
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:47.522
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:50.261
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:52.223
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:53.514
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:54.770
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:55.827
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:13:59.130
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:14:52.836
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:15:25.282
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:18:59.776
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:19:14.180
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:31:57.656
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:32:21.495
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:32:27.988
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:35:32.979
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:42:42.539
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 11:42:54.467
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:05:05.883
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:08:23.765
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:08:32.468
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:08:41.051
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:09:25.411
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:12:46.404
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:15:26.181
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:23:32.025
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:24:13.795
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:26:36.842
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:26:55.853
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:27:01.839
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:27:05.070
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:27:34.994
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:28:25.150
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:28:33.293
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:29:00.267
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:30:00.759
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:30:17.806
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:30:54.536
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:32:21.780
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:32:49.166
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:33:09.776
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:34:23.325
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:34:37.758
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:34:55.487
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:35:33.336
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:42:27.804
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:48:55.360
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:50:54.782
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:51:16.897
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:51:52.352
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 12:53:13.765
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:45:30.513
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:48:28.721
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:48:39.840
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:49:50.127
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:52:06.258
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:52:25.148
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:52:29.813
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:52:36.274
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:52:42.304
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:56:05.770
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:56:53.309
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:57:28.499
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 13:59:49.119
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:02:00.334
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:37.076
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:39.972
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:42.293
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:44.418
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:47.788
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:50.501
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:03:53.465
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:04:02.182
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:05:51.041
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:16:34.621
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:29:23.744
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:29:33.289
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:29:45.130
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:30:42.109
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:31:08.132
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:31:39.074
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:32:03.576
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:46:38.530
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:47:09.157
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:53:23.040
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 14:54:11.752
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:00:58.291
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:05:44.606
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:05:58.195
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:09:07.159
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:09:10.403
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:09:12.067
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:10:19.304
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:10:21.856
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:10:25.727
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:12:05.781
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:22:31.575
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:22:48.324
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:24:20.583
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:24:36.588
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:24:50.059
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:46:36.368
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:47:29.348
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:47:42.198
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:48:07.475
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:48:40.165
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 15:56:54.709
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:00:16.925
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:00:40.179
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:01:34.215
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:02:54.894
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:05:06.608
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:05:31.367
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:09:44.895
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:09:56.017
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:10:44.648
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:11:54.231
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:16:41.140
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:04.986
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:10.582
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:15.955
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:33.992
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:47.071
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:17:54.396
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:25:19.227
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:26:13.841
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:26:38.432
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:26:42.598
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:26:47.637
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:26:53.166
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:27:24.020
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:27:39.166
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:27:44.842
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:29:44.922
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:35:30.932
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:44:14.687
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:44:18.361
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:44:25.978
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:45:30.140
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:47:07.292
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:47:49.266
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:51:06.476
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:51:30.404
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:51:47.293
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:52:06.213
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:52:31.809
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:53:33.172
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:53:44.132
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:53:56.717
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:54:12.240
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:55:07.825
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 16:55:16.298
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:03:20.065
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:02.673
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:06.468
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:08.249
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:09.620
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:10.712
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:12.255
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:13.674
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:15.008
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:07:51.079
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:08:31.609
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:08:33.773
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:08:35.054
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:14:24.234
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:14:39.552
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:16:45.667
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:16:58.663
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:17:34.053
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:18:32.717
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:19:16.038
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:19:31.435
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:20:34.947
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:21:04.886
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:22:31.475
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:26:19.091
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-05 17:30:06.221
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-06 09:10:34.561 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-06 09:10:43.334
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-06 09:10:43.334
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5350ab17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@984de01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-06 09:10:49.802
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:11:21.043
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:12:55.006
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:14:08.110
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:14:19.185
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:14:45.733
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:15:52.136
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:16:06.783
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:16:16.809
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:23:02.152
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:23:38.091
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:24:48.714
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:24:56.424
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:29:02.405
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:30:56.334
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:31:05.742
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:32:19.139
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:35:22.919
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:40:16.753
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:41:01.328
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:41:06.492
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:41:12.453
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:41:29.886
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:42:33.061
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:42:41.787
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:44:41.450
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:45:17.029
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:45:27.787
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:46:29.069
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-06 09:46:43.444 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-06 09:46:52.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-06 09:46:52.960
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@48632f69,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fde1d64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-06 09:46:57.944
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:47:00.597
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:47:36.471
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:47:43.119
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:48:13.043
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:48:14.115
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:49:00.860
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:49:13.054
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:49:35.590
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:50:34.578
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:50:39.146
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 09:50:51.843
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-04-06 09:51:28.721
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1358)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:769)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:399)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:308)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.findVariable(JDIStackFrame.java:929)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findLocalVariable(JavaDebugHover.java:146)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:446)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 130 2023-04-06 09:51:28.723
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-04-06 10:07:39.263
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1358)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:769)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:399)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:308)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.findVariable(JDIStackFrame.java:929)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findLocalVariable(JavaDebugHover.java:146)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:446)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 130 2023-04-06 10:07:39.264
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:07:53.519
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:08:04.478
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:09:47.171
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:13:11.788
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:15:29.719
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-04-06 10:16:04.341
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1358)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:769)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:399)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:308)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.findVariable(JDIStackFrame.java:929)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findLocalVariable(JavaDebugHover.java:146)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:446)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 130 2023-04-06 10:16:04.341
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-04-06 10:16:15.057
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1358)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:769)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:399)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:308)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.findVariable(JDIStackFrame.java:929)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findLocalVariable(JavaDebugHover.java:146)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:446)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 130 2023-04-06 10:16:15.057
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-04-06 10:16:21.340
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1358)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:769)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:399)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:308)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.findVariable(JDIStackFrame.java:929)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findLocalVariable(JavaDebugHover.java:146)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:446)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 130 2023-04-06 10:16:21.340
!MESSAGE Invalid stack frame

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:17:02.049
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 10:23:33.489
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-06 11:10:23.790 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-06 11:10:33.536
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-06 11:10:33.536
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fde1d64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5350ab17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-06 11:10:38.817
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 11:18:42.919
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 11:18:54.398
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 14:26:17.057
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 14:29:09.615
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 14:30:24.774
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 15:21:22.438
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 15:21:35.761
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 15:31:39.408
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 15:54:50.690
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 15:55:16.572
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:11:15.743
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:12:35.262
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:46:50.832
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:47:00.451
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:47:10.199
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:47:27.896
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:47:42.100
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:47:58.348
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:48:46.157
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 16:49:03.729
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 17:00:17.336
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.core 4 4 2023-04-06 17:11:20.937
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package e_oop;

import java.util.Scanner;

public class Running {
	
	boolean power;
	double speed;
	int time;
	int incline;
	int temp;
	double cal;
	double weight;
	static String wtf;
	
	static Scanner sc = new Scanner(System.in);

	boolean power() {
		if(wtf.equals("on")) {
			this.power = true;
		} else {
			this.power = false;
		}
		
		return this.power;
	}
	
	void speed() {
		(speed >= 6) {
			System.out.println("이제 한계야..");
			speed = 5.5;
		if (wtf.equals("spup")) {
			speed += 0.5;
			System.out.println("현재 속도 : " + speed);
		} else if (wtf.equals("spdown")) {
			speed -= 0.5;
			System.out.println("현재 속도 : " + speed);
		} else if(speed >= 6) {
			System.out.println("이제 한계야..");
			speed = 5.5;
		}
	}
	
	public static void main(String[] args) {

		Running run = new Running();
		
		String option =   "[\n"
						+ "전원 키기 : on /\n "
						+ "전원 끄기 : off /\n "
						+ "속도 조절 : spup OR spdown OR \"속도입력\" /\n "
						+ "각도 조절 : incup OR incdown\n"
						+ "]";
		
//		System.out.println(option);
		
		while(true) {
			System.out.println(option);
			wtf = sc.nextLine();
			
			if (wtf.equals("on") || wtf.equals("off")) {
				if(run.power()) {
					System.out.println("런닝 머신이 시작되었습니다. 런닝맨.");
					
				} else {
					System.out.println("런닝 머신이 종료되었습니다. 멈춰!");
					break;
				}
			} else if (wtf.equals("spup") || wtf.equals("spdown")) {
				run.speed();
			} else if (wtf.equals("속도입력")) {
				
			} else if (wtf.equals("incup") || wtf.equals("incdown")) {
				
			}
				
				
				
		}
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-06 17:11:20.941
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-06 17:11:20.942
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-06 17:11:21.876
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package e_oop;

import java.util.Scanner;

public class Running {
	
	boolean power;
	double speed;
	int time;
	int incline;
	int temp;
	double cal;
	double weight;
	static String wtf;
	
	static Scanner sc = new Scanner(System.in);

	boolean power() {
		if(wtf.equals("on")) {
			this.power = true;
		} else {
			this.power = false;
		}
		
		return this.power;
	}
	
	void speed() {
		(speed >= 6) {
			System.out.println("이제 한계야..");
			speed = 5.5;
		if (wtf.equals("spup")) {
			speed += 0.5;
			System.out.println("현재 속도 : " + speed);
		} else if (wtf.equals("spdown")) {
			speed -= 0.5;
			System.out.println("현재 속도 : " + speed);
		} else if(speed >= 6) {
			System.out.println("이제 한계야..");
			speed = 5.5;
		}
	}
	
	public static void main(String[] args) {

		Running run = new Running();
		
		String option =   "[\n"
						+ "전원 키기 : on /\n "
						+ "전원 끄기 : off /\n "
						+ "속도 조절 : spup OR spdown OR \"속도입력\" /\n "
						+ "각도 조절 : incup OR incdown\n"
						+ "]";
		
//		System.out.println(option);
		
		while(true) {
			System.out.println(option);
			wtf = sc.nextLine();
			
			if (wtf.equals("on") || wtf.equals("off")) {
				if(run.power()) {
					System.out.println("런닝 머신이 시작되었습니다. 런닝맨.");
					
				} else {
					System.out.println("런닝 머신이 종료되었습니다. 멈춰!");
					break;
				}
			} else if (wtf.equals("spup") || wtf.equals("spdown")) {
				run.speed();
			} else if (wtf.equals("속도입력")) {
				
			} else if (wtf.equals("incup") || wtf.equals("incdown")) {
				
			}
				
				
				
		}
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-06 17:11:21.877
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-06 17:11:21.877
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-06 17:18:27.606
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-07 09:11:50.517 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 09:12:00.214
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 09:12:00.214
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20027c44,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7eae55,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 4 2023-04-07 09:12:04.798
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/e_oop/TV_home_training.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3210)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3221)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1294)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:545)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:529)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1084)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/e_oop/TV_home_training.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1022)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1288)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4212)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:260)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1476)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2575)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2548)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1423)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3179)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2320)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3196)
	... 132 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2023-04-07 09:12:04.813
!MESSAGE Cannot determine URI for '/드론4기 프로그래밍 초급/src/e_oop/TV_home_training.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/e_oop/TV_home_training.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1022)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1288)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4212)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:260)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1476)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2575)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2548)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1423)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3179)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2320)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3196)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3221)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1294)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:545)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:529)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1084)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2023-04-07 09:12:04.813
!MESSAGE Cannot determine URI for '/드론4기 프로그래밍 초급/src/e_oop/TV_home_training.java'.

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 09:12:06.048
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-07 09:22:21.939 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 09:22:27.080
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 09:22:27.080
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3b362f1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6451a288,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 09:22:31.205
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-07 09:42:16.054
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-07 09:42:37.743
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-07 16:58:18.828 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 16:58:31.586
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 16:58:31.586
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59313495,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a04ca74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 16:58:38.284
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-07 17:00:06.253 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 17:00:11.052
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 17:00:11.052
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67d5ac2f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25109608,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 17:00:15.819
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2023-04-07 17:06:28.355
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2023-04-10 09:09:56.205 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-10 09:10:11.276
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 09:10:11.276
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c839677,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3193e21d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 4 2023-04-10 09:10:15.820
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/GameProject/Main.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3210)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3221)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1294)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:545)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:529)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1084)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/GameProject/Main.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1022)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1288)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4212)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:260)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1476)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2575)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2548)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1423)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3179)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2320)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3196)
	... 124 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2023-04-10 09:10:15.820
!MESSAGE Cannot determine URI for '/드론4기 프로그래밍 초급/src/GameProject/Main.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/드론4기 프로그래밍 초급/src/GameProject/Main.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1022)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1288)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4212)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:260)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1476)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2575)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2548)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1423)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3179)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2320)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3196)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3221)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1294)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:545)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:529)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:1000)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:148)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:666)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:674)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$0(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1084)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2023-04-10 09:10:15.820
!MESSAGE Cannot determine URI for '/드론4기 프로그래밍 초급/src/GameProject/Main.java'.

!ENTRY org.eclipse.egit.ui 2 0 2023-04-10 09:10:16.603
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2023-04-10 10:20:51.000
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Unknown javadoc format for TODO {key=Lcom/sun/xml/internal/bind/v2/TODO;} [in TODO.class [in com.sun.xml.internal.bind.v2 [in C:\Program Files\Java\jre1.8.0_351\lib\rt.jar]]]]
	at org.eclipse.jdt.internal.core.JavadocContents.getTypeDoc(JavadocContents.java:84)
	at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:1023)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:534)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:760)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 1009 2023-04-10 10:20:51.001
!MESSAGE Unknown javadoc format for TODO {key=Lcom/sun/xml/internal/bind/v2/TODO;} [in TODO.class [in com.sun.xml.internal.bind.v2 [in C:\Program Files\Java\jre1.8.0_351\lib\rt.jar]]]
!SESSION 2023-04-10 12:34:02.046 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_351
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-10 12:34:11.191
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-10 12:34:11.191
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@586728e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3316527e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-10 12:34:16.191
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\admin'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.help.base 2 0 2023-04-10 13:34:00.413
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.jdt.doc.user_3.15.700.v20200603-0557 [216]'. The index should be rebuilt with Lucene 8.4.1

!ENTRY org.eclipse.help.base 2 0 2023-04-10 13:34:00.417
!MESSAGE Unable to consume Lucene index from bundle 'org.eclipse.platform.doc.user_4.16.0.v20200603-1002 [354]'. The index should be rebuilt with Lucene 8.4.1

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:23.092
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 13:49:23.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 13:49:23.096
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:24.072
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 13:49:24.077
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 13:49:24.081
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:26.116
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 13:49:26.120
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 13:49:26.123
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:27.000
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 13:49:27.003
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 13:49:27.006
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:31.644
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ ""
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 13:49:31.647
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 13:49:31.650
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:31.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ ""
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-10 13:49:31.666
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-10 13:49:31.667
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:32.670
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ "1"
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 13:49:32.673
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-10 13:49:32.675
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-10 13:49:34.692
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package GameProject;

import java.util.Scanner;

public class Main {

	static boolean power;
	static String input;
	static String username;
	static Scanner s = new Scanner(System.in);
	
//============================================전원============================================
	void power() {
		String powerOnOff = s.nextLine();
		if (powerOnOff.equals("start")) {
			System.out.println("게임이 시작됩니다.\n\t\t\t(n)을 입력하면 다음으로 넘어갑니다.");
			power = true;
		} else if (powerOnOff.equals("end")) {
			System.out.println("게임이 꺼집니다. 꺼지세요.");
			power = false;
		}
	}
//============================================유저 이름============================================
	static void userName() {
		System.out.println("사용할 이름을 입력하세요.");
		String userName = s.nextLine();
		System.out.println("당신의 이름은 " + userName + " 입니다.");
		System.out.println("stage_1을 입력하면 게임을 진행합니다.");
		Main.username = userName;
	}
//============================================다음============================================
	static void next() {
		System.out.println("\n\t\t\t다음 (n)");
	}
//============================================스테이지============================================
	
	void stage_1() {
		System.out.println("\nㅡ stage_1 : 고통의 시작 ㅡ\n"
				+ "내 이름은 " + "\"" + username + "\"" + " dw 아카데미의 학생이다.\n"
				+ "내가 dw 아카데미에 첫발을 들인건 2023년 3월..\n"
				+ "지금으로부터 8년전이었다..\n"
				+ "개백수였던 나는 먹고 살길을 찾아 이곳에 왔다..");
		Main.next();
		String inputstage = s.nextLine();
		for ( ; ; ) {
			if (inputstage.equals("n")) {
				System.out.println("오전 8시.. 알람이 울린다..\n오늘은 월요일.. 학원을 어떻게하지?\n"
						+ "1)다시 잔다. 2)ㅈ같지만 일어난다.\n\n"
						+ "\t\t\t입력 (1, 2)");
				String inputstage2 = s.nextLine();
				if (inputstage2.equals("1")) {
					System.out.println("다시 생각해\n");
				} else if (inputstage2.equals("2")) {
					System.out.println("(우당탕탕)\n\n\n..\n\n\n나갈 준비는 끝났다.. 뭘 타고 갈까?\n"
							+ "교통 수단을 선택하세요.\n"
							+ "1)차를 가져간다. 2)지하철을 이용한다.\n\n"
							+ "\t\t\t입력 (1, 2)");
					String inputstage3 = s.nextLine();
					if (inputstage3.equals("1")) {
						System.out.println("차가 없으므로 지하철을 이용한다.\n");
						break;
					} else if (inputstage3.equals("2")) {
						System.out.println("지하철을 이용한다.\n");
						break;
					}
				}
			}
		} // for 종료
		System.out.println("stage_2를 입력하면 게임을 진행합니다.");
	}
	
	void stage_2() {
		System.out.println("학원에 도착해버렸다.. 지문을 찍고 드론 21기 교실로 들어선다.\n"
				+ "클래스를 이해하지 못한 나는 8년째 재수강을 하고 있다..\n"
				+ "이제 그만 수료를 하고 싶다..\n"
				+ "드론4기에서 처음만났던 담임선생님은 나 때문에\n"
				+ "8년째 클래스 수업을 해주고 계신다..\n"
				+ "언제나처럼 선생님은 아침마다 하시는 말씀이 있다.\n"
				+ "선생님 : " + username + "님 복습했어요 안했어요\n"
				+ "1) "
				+ "\t\t\t입력 (1, 2)");
				+ username + " : 죄송합니다 쓰앵님..");
		String inputstage = s.nextLine();
	}

	void stage_3() {
		
	}

	void stage_4() {
		
	}

	void stage_5() {
		
	}
	
//==============================================================================================

	
	
	
	public static void main(String[] args) {
	
		Main main = new Main();
		
		// 게임 시작 안내
		System.out.println("ㅡDW 아카데미 탈출하기ㅡ\n\"start\"를 입력하면 게임이 시작됩니다.");
		
		// 전원
		main.power();
		
		String inputUserName = s.nextLine();
		main.userName();
		// start 입력 -> 반복문 시작
		while (power) {
			String inputStage = s.nextLine();
			if (inputStage.equals("stage_1")) {
				main.stage_1();
			} else if (inputStage.equals("stage_2")) {
				main.stage_2();
			} else if (inputStage.equals("stage_3")) {
				main.stage_3();
			} else if (inputStage.equals("stage_4")) {
				main.stage_4();
			} else if (inputStage.equals("stage_5")) {
				main.stage_5();
			}
			
			
		}
		
		
		
		
		
		
		
		
		
		
		
	} // main 종료














	

} // class 종료

/* 에로사항
 * 1. start를 입력하여 게임을 시작한 후 바로 입력한 텍스트를 userName으로 하고 싶은데 안되서 n을 입력받아 다음으로 넘어가야 userName을 입력 받을 수 있게 하였다.
 */




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-10 13:49:34.695
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
